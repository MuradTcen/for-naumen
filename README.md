#### Тестовое задание на стажировку Naumen (Scala)
Необходимо написать приложение на Scala, которое представляет из себя http
сервер , предоставляющий REST API для работы с телефонным справочником со
следующим функционалом (бэкенд):
- добавить телефон (строка) и имя (строка) в справочник
- получить список ранее добавленных вхождений в справочник (кортеж
<id, имя, номер>) в виде json
- изменить значения телефона или имени во вхождении выбранному по id
- удалить из справочника вхождение по id
- поиск всех вхождений по подстроке имени
- поиск всех вхождений по подстроке номера
Пример API будет приведен в приложении.
Минимальное работоспособное приложение может хранить все данные в
памяти и, соответственно, терять их при перезапуске.
Далее предлагаем реализовать ряд усовершенствований данного приложения.
Это позволит вам проявить глубину своих знаний и навыков и повысить шансы
попасть на стажировку. Они не обязательные и мы не ожидаем что вы их выполните
все. Пункты расположены в порядке приоритета (первые - самые важные и
показательные, их стоит делать в первую очередь). Сложность пунктов не одинаковая
и оцениваться они будут соответственно.

##### В первую очередь целесообразно сделать:
1. Добавить хранение данных в реляционной БД
2. Добавить клиентское веб-приложение - фронтенд (html, css, js, работает
в браузере), которое будет работать с данным API бекенда. Например,
html страничка, в которой с помощью javascript по ajax запрашиваются
данные всех ранее добавленных вхождений и отображаются списком,
рядом с каждым вхождением добавить кнопку его удаления. Отдельно
реализовать форму сохранения нового или редактирования 
существующего вхождения. Отдельно реализовать строку поиска
вхождений по подстроке.

##### Затем в качестве задания “со звездочкой” для самых продвинутых предлагаем
реализовать что-то из следующего:
1. Добавить в серверную часть метод API по которому асинхронно
происходит сохранение всех данных справочника на жесткий диск (файл
где данные записаны в текстовом виде, в простом и человекочитаемом
формате типа csv или json).
2. Добавить валидацию на бэкенде на добавление записи (формат
телефонного номера в виде: +<код страны><номер внутри страны>,
проверка на добавление дубля, проверка на другие некорректные
данные на ваше усмотрение). Дополнительно: для клиентского
приложения выводить на страницу сообщение об ошибке при
непрохождении валидации.
3. Добавить функционал автоматического удаления вхождения через
некоторое заданное время (например, 1 год) после его внесения в
справочник.
4. Добавить кэширование запрашиваемых из БД данных в памяти
приложения (самописный механизм кэширования).
Разрешено использование любых инструментов, библиотек и фреймворков. "При
отсутствии предпочтений рекомендуем использовать следующие технологии - sbt, Play
2 framework, Slick, postgres"
Важно! Работающее приложение с минимальным (но корректным) функционалом
важнее чем несколько неработающих задумок.
##### Что мы ожидаем от вас:
1. Исходный код приложения (желательно в виде git-репозитория)
2. Инструкция как развернуть окружение и запустить ваше приложение (желательно
чтобы инструкция была кроссплатформенной или под linux)
3. Описание того как пользоваться вашим приложением (сценарии использования или
описание API и примеры запросов)
4. Дополнительно: описание архитектуры и особенностей реализации вашего
приложения в свободной форме (реализация чего в вашем приложении вам нравится,
что вы намеренно упростили для экономии времени на реализацию, что бы вы хотели
улучшить в нем и как вы бы это сделали)

#### Приложение
Пример простого API которое можно взять за основу:
- добавить телефон (строка) и имя (строка) в справочник
endpoint: POST /phones/createNewPhone
data: в теле запроса json вида { “phoneNumber”: “12345”, “name”: “qwerty” }
- получить список ранее добавленных вхождений в справочник (кортеж
<id, имя, номер>) в виде json
endpoint: GET /phones
response: json вида

`
[

{ “phoneNumber”: “12345”, “name”: “qwerty” },

{ “phoneNumber”: “12346”, “name”: “qwerty2” },

...

{ “phoneNumber”: “12345N”, “name”: “qwertyN” }

]

`
- изменить значения телефона или имени во вхождении выбранному по id
endpoint: POST /phone/{id}
data: в теле запроса json вида { “phoneNumber”: “12345”, “name”: “qwerty” }
- удалить из справочника вхождение по id
endpoint: DELETE /phone/{id}
- поиск всех вхождений по подстроке имени
endpoint: GET /phones/searchByName?nameSubstring=<...>
- поиск всех вхождений по подстроке номера
endpoint: GET /phones/searchByNumber?phoneSubstring=<...>

---------------------------

##### Что сделано:
1. Back-end Rest API (Java 8, Spring Boot, Liquibase, Swagger), Front-end (js, React.js), слой БД (PostgresQL)

2. БД: простая таблица Phones с аудит-полями created_at и updated_at. Created_at используется для удаления записей через
 определенное время. Расписание запуска задаётся через cron-выражение. Время жизни телефонных номеров захардкожено.  

3. Back-end: слой контроллеров, сервисов, сущностей, репозиториев, утилит(валидация, кэш)
Есть своя аннотация @PhoneConstraint для проверки на соответствие формату "+7<999><9999999>". Работа с сущностями
через репозиторий, используется Specification для фильтрации.

4. Front-End: React.js, react-bootstrap: ошибки валидации выводятся
[![imageup.ru](https://imageup.ru/img160/3625426/validation-error.png)](https://imageup.ru/img160/3625426/validation-error.png.html)

Поиск вхождений:
По имени:
[![imageup.ru](https://imageup.ru/img171/3625427/searchname.png)](https://imageup.ru/img171/3625427/searchname.png.html)

По номеру:
[![imageup.ru](https://imageup.ru/img33/3625428/searchnumber.png)](https://imageup.ru/img33/3625428/searchnumber.png.html)

5. Есть немного тестов на бэке для валидации

6. Есть Swagger

##### Проблемы и комментарии:

1. Больше бы поработал с кэшем и с CompletableFuture (Сохранение дампа на жесткий диск) 

2. Интереснее было бы сделать задание в рекомендуемом стеке Scala, Play 2, Slick , но сделал просмотр технологий и оценку времени и
решил сделать в стеке Java и Spring

##### Запуск под Linux:

Сборка проекта: `./gradlew build`

Сборка докер-контейнера: `sudo docker build -t app .`

Запуск докер-контейнера: `sudo docker run app`

Завершение докер-контейнера: `sudo docker stop CONTAINER ID`

Узнать CONTAINER ID докер-контейнера: `sudo docker ps`

Доступно описание API через SWAGGER: `http://localhost:8080/swagger-ui.html#`

Задеплоено на Heroku: `https://naumen-phones.herokuapp.com`

Соответственно SWAGGER на Heroku: `https://naumen-phones.herokuapp.com//swagger-ui.html#`

